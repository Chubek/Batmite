{{
	This project contains several preprocessors in Perl

	- `treepp.pl`: Transforms tree grammars into instantiation of trees based on given macros/functions
	- `execpp.pl`: Excutes inline commands and emits output

	- `herepp.pl`: Preprocesses here-strings into legal C strings

	- `opcodepp.pl`: A language used to describe opcodes, this script transforms it into several target forms

	- `allocpp.pl`: Generates heap allocations for a function or globally

	- `asmpp.pl`: Generates a binarizer in C based on the given Assembly language grammar


	The grammar for all these preprocessors in given below

}}

{ A. Grammar: TreePP; Author: Chubak Bidpaa }

tree-decl 	::= "%tree" [ tree-storage ] tree-name [ tree-parent] tree-value [ tree-left ] [ tree-right ] 

tree-storage    ::= "%static" | "%heap" 

tree-name 	::= "%name" tree-ident 
tree-value	::= "%value" tree-node 
tree-parent	::= "%parent" tree-ident 
tree-right 	::= "%right" tree-ident 
tree-left	::= "%left" tree-ident 

tree-ident	::= identifier 
tree-node	::= number | string | identifier 

number		::= ? any valid C numeric value ? 
string		::= ? any valid C string sequence ? 
identifier	::= ? any valid C identifier ? 


{ B. Grammar: ExecPP; Author: Chubak Bidpaa }

execute-shell-inline ::= '`' ? any ascii sequence ? '`' 

{ C. Grammar: HerePP; Author: Chubak Bidpaa }

here-str	::= here-starts ? valid ascii sequence ? here-ident 

here-starts     ::= ? any ascii sequence ? '=' "<<<" here-ident 

here-ident 	::= "END_" ident "_STR" 

ident 		::= letter { letter | digit | '_' } 

digit 		::= '0' | '1' | ... | '9'
letter 		::= 'A' | 'B' | 'C' | ... | 'z' 


{ D. Grammar: OpcodePP; Author: Chubak Bidpaa }

opcode-pp	::= opcode-list [ { comment } ]

opcode-list 	::= opcode-decl { ';' opcode-decl }

comment		::= "--" text

opcode-decl	::= '%' opcode-name "of" operand-name

operand-list	::= operand-name { '*' operand-name }

operand-name	::= { lowercase }

opcode-name     ::= { uppercase }

identifier      ::= letter { letter | digit | '_' }

letter 		::= lowercase | uppercase

lowercase	::= 'a' | 'b' | ... | 'z'

uppercase       ::= 'A' | 'B' | ... | 'Z'

text		::= { any-char }

any-char	::= ? any-valid-ASCII-char ?

{ E. Grammar: AllocPP; Author: Chubak Bidpaa }

preprocessor-directive ::= 
	  '#alloc' [ lexical-scope ] identifier alloc-arguments newline 
	| '#realloc' [ lexical-scope ] identifier realloc-arguments newline

realloc-arguments ::= '(' [ "size=" ] size ',' [ "step=" ] size ')'

alloc-arguments ::= '(' [ "size=" ] size ')'

lexical-scope 	::= "%global" | "%function" identifier

size 		::= ? any-valid-text ?

identifier 	::= letter { letter | digit | '_' }

newline 	::= '\n'

integer-literal ::= digit { digit }

letter 		::= 'a' | 'b' | ... | 'z' | 'A' | 'B' | ... | 'Z'

digit 		::= '0' | '1' | ... | '8' | '9'

{ F. Grammar: AsmPP; Author: Chubak Bidpaa }

pattern-match	 ::= "emission" "ID=" integer-literal '=' condition-list ';'

condition-list	 ::= condition { '|' condition }

condition	 ::= case-op { ( case-reg | case-memory | case-const ) } '{' any-text '}'

case-op		 ::= "op?" opcode-name
case-reg	 ::= "reg?" register-name 
case-memory	 ::= "mem?"
case-const	 ::= "const?"

machine-opcode   ::= "%mopc" { opcode-name '=' integer-literal }

machine-register ::= "%mreg" { register-name '=' integer-literal }

opcode-name	::= letter { letter | digit | '_' }

register-name   ::= letter { letter | digit }

comment 	::= ';'  any-text  newline

label 		::= letter { letter | digit | '_' }

opcode 		::= letter { letter }

integer-literal ::= digit { digit }
		 | { ( digit | hex-digit ) } 'H'
		 | { oct-digit } 'O'

newline 	::= '\n'

letter 		::= 'a' | 'b' | ... | 'z' | 'A' | 'B' | ... | 'Z'

oct-digit	::= '0' | '1' | ... | '7' 

hex-digit	::= 'A' | 'B' | ... | 'F' | 'a' | 'b' | ... | 'f'

digit 		::= '0' | '1' | ... | '8' | '9'

any-text 	::= ? any-valid-text ?

